/* automatically generated by rust-bindgen 0.71.1 */

pub const C_API_DTYPE_FLOAT32: u32 = 0;
pub const C_API_DTYPE_FLOAT64: u32 = 1;
pub const C_API_DTYPE_INT32: u32 = 2;
pub const C_API_DTYPE_INT64: u32 = 3;
pub const C_API_PREDICT_NORMAL: u32 = 0;
pub const C_API_PREDICT_RAW_SCORE: u32 = 1;
pub const C_API_PREDICT_LEAF_INDEX: u32 = 2;
pub const C_API_PREDICT_CONTRIB: u32 = 3;
pub const C_API_MATRIX_TYPE_CSR: u32 = 0;
pub const C_API_MATRIX_TYPE_CSC: u32 = 1;
pub const C_API_FEATURE_IMPORTANCE_SPLIT: u32 = 0;
pub const C_API_FEATURE_IMPORTANCE_GAIN: u32 = 1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrowSchema {
    pub format: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub metadata: *const ::std::os::raw::c_char,
    pub flags: i64,
    pub n_children: i64,
    pub children: *mut *mut ArrowSchema,
    pub dictionary: *mut ArrowSchema,
    pub release: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ArrowSchema)>,
    pub private_data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ArrowSchema"][::std::mem::size_of::<ArrowSchema>() - 72usize];
    ["Alignment of ArrowSchema"][::std::mem::align_of::<ArrowSchema>() - 8usize];
    ["Offset of field: ArrowSchema::format"][::std::mem::offset_of!(ArrowSchema, format) - 0usize];
    ["Offset of field: ArrowSchema::name"][::std::mem::offset_of!(ArrowSchema, name) - 8usize];
    ["Offset of field: ArrowSchema::metadata"]
        [::std::mem::offset_of!(ArrowSchema, metadata) - 16usize];
    ["Offset of field: ArrowSchema::flags"][::std::mem::offset_of!(ArrowSchema, flags) - 24usize];
    ["Offset of field: ArrowSchema::n_children"]
        [::std::mem::offset_of!(ArrowSchema, n_children) - 32usize];
    ["Offset of field: ArrowSchema::children"]
        [::std::mem::offset_of!(ArrowSchema, children) - 40usize];
    ["Offset of field: ArrowSchema::dictionary"]
        [::std::mem::offset_of!(ArrowSchema, dictionary) - 48usize];
    ["Offset of field: ArrowSchema::release"]
        [::std::mem::offset_of!(ArrowSchema, release) - 56usize];
    ["Offset of field: ArrowSchema::private_data"]
        [::std::mem::offset_of!(ArrowSchema, private_data) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrowArray {
    pub length: i64,
    pub null_count: i64,
    pub offset: i64,
    pub n_buffers: i64,
    pub n_children: i64,
    pub buffers: *mut *const ::std::os::raw::c_void,
    pub children: *mut *mut ArrowArray,
    pub dictionary: *mut ArrowArray,
    pub release: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ArrowArray)>,
    pub private_data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ArrowArray"][::std::mem::size_of::<ArrowArray>() - 80usize];
    ["Alignment of ArrowArray"][::std::mem::align_of::<ArrowArray>() - 8usize];
    ["Offset of field: ArrowArray::length"][::std::mem::offset_of!(ArrowArray, length) - 0usize];
    ["Offset of field: ArrowArray::null_count"]
        [::std::mem::offset_of!(ArrowArray, null_count) - 8usize];
    ["Offset of field: ArrowArray::offset"][::std::mem::offset_of!(ArrowArray, offset) - 16usize];
    ["Offset of field: ArrowArray::n_buffers"]
        [::std::mem::offset_of!(ArrowArray, n_buffers) - 24usize];
    ["Offset of field: ArrowArray::n_children"]
        [::std::mem::offset_of!(ArrowArray, n_children) - 32usize];
    ["Offset of field: ArrowArray::buffers"][::std::mem::offset_of!(ArrowArray, buffers) - 40usize];
    ["Offset of field: ArrowArray::children"]
        [::std::mem::offset_of!(ArrowArray, children) - 48usize];
    ["Offset of field: ArrowArray::dictionary"]
        [::std::mem::offset_of!(ArrowArray, dictionary) - 56usize];
    ["Offset of field: ArrowArray::release"][::std::mem::offset_of!(ArrowArray, release) - 64usize];
    ["Offset of field: ArrowArray::private_data"]
        [::std::mem::offset_of!(ArrowArray, private_data) - 72usize];
};
pub type DatasetHandle = *mut ::std::os::raw::c_void;
pub type BoosterHandle = *mut ::std::os::raw::c_void;
pub type FastConfigHandle = *mut ::std::os::raw::c_void;
pub type ByteBufferHandle = *mut ::std::os::raw::c_void;
unsafe extern "C" {
    #[doc = "Get string message of the last error.\n # Returns\n\nError information"]
    pub fn LGBM_GetLastError() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "Dump all parameter names with their aliases to JSON.\n # Arguments\n\n* `buffer_len` - String buffer length, if ``buffer_len < out_len``, you should re-allocate buffer\n * `out_len` (direction out) - Actual output length\n * `out_str` (direction out) - JSON format string of parameters, should pre-allocate memory\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DumpParamAliases(
        buffer_len: i64,
        out_len: *mut i64,
        out_str: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Register a callback function for log redirecting.\n # Arguments\n\n* `callback` - The callback function to register\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_RegisterLogCallback(
        callback: ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get number of samples based on parameters and total number of rows of data.\n # Arguments\n\n* `num_total_row` - Number of total rows\n * `parameters` - Additional parameters, namely, ``bin_construct_sample_cnt`` is used to calculate returned value\n * `out` (direction out) - Number of samples. This value is used to pre-allocate memory to hold sample indices when calling ``LGBM_SampleIndices``\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_GetSampleCount(
        num_total_row: i32,
        parameters: *const ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Create sample indices for total number of rows.\n > **Note:** You should pre-allocate memory for ``out``, you can get its length by ``LGBM_GetSampleCount``.\n # Arguments\n\n* `num_total_row` - Number of total rows\n * `parameters` - Additional parameters, namely, ``bin_construct_sample_cnt`` and ``data_random_seed`` are used to produce the output\n * `out` (direction out) - Created indices, type is int32_t\n * `out_len` (direction out) - Number of indices\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_SampleIndices(
        num_total_row: i32,
        parameters: *const ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_void,
        out_len: *mut i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get a ByteBuffer value at an index.\n # Arguments\n\n* `handle` - Handle of byte buffer to be read\n * `index` - Index of value to return\n * `out_val` (direction out) - Byte value at index to return\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_ByteBufferGetAt(
        handle: ByteBufferHandle,
        index: i32,
        out_val: *mut u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Free space for byte buffer.\n # Arguments\n\n* `handle` - Handle of byte buffer to be freed\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_ByteBufferFree(handle: ByteBufferHandle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Load dataset from file (like LightGBM CLI version does).\n # Arguments\n\n* `filename` - The name of the file\n * `parameters` - Additional parameters\n * `reference` - Used to align bin mapper with other dataset, nullptr means isn't used\n * `out` (direction out) - A loaded dataset\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetCreateFromFile(
        filename: *const ::std::os::raw::c_char,
        parameters: *const ::std::os::raw::c_char,
        reference: DatasetHandle,
        out: *mut DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Allocate the space for dataset and bucket feature bins according to sampled data.\n # Arguments\n\n* `sample_data` - Sampled data, grouped by the column\n * `sample_indices` - Indices of sampled data\n * `ncol` - Number of columns\n * `num_per_col` - Size of each sampling column\n * `num_sample_row` - Number of sampled rows\n * `num_local_row` - Total number of rows local to machine\n * `num_dist_row` - Number of total distributed rows\n * `parameters` - Additional parameters\n * `out` (direction out) - Created dataset\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetCreateFromSampledColumn(
        sample_data: *mut *mut f64,
        sample_indices: *mut *mut ::std::os::raw::c_int,
        ncol: i32,
        num_per_col: *const ::std::os::raw::c_int,
        num_sample_row: i32,
        num_local_row: i32,
        num_dist_row: i64,
        parameters: *const ::std::os::raw::c_char,
        out: *mut DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Allocate the space for dataset and bucket feature bins according to reference dataset.\n # Arguments\n\n* `reference` - Used to align bin mapper with other dataset\n * `num_total_row` - Number of total rows\n * `out` (direction out) - Created dataset\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetCreateByReference(
        reference: DatasetHandle,
        num_total_row: i64,
        out: *mut DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Initialize the Dataset for streaming.\n # Arguments\n\n* `dataset` - Handle of dataset\n * `has_weights` - Whether the dataset has Metadata weights\n * `has_init_scores` - Whether the dataset has Metadata initial scores\n * `has_queries` - Whether the dataset has Metadata queries/groups\n * `nclasses` - Number of initial score classes\n * `nthreads` - Number of external threads that will use the PushRows APIs\n * `omp_max_threads` - Maximum number of OpenMP threads (-1 for default)\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetInitStreaming(
        dataset: DatasetHandle,
        has_weights: i32,
        has_init_scores: i32,
        has_queries: i32,
        nclasses: i32,
        nthreads: i32,
        omp_max_threads: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Allocate the space for dataset and bucket feature bins according to serialized reference dataset.\n # Arguments\n\n* `ref_buffer` - A binary representation of the dataset schema (feature groups, bins, etc.)\n * `ref_buffer_size` - The size of the reference array in bytes\n * `num_row` - Number of total rows the dataset will contain\n * `num_classes` - Number of classes (will be used only in case of multiclass and specifying initial scores)\n * `parameters` - Additional parameters\n * `out` (direction out) - Created dataset\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetCreateFromSerializedReference(
        ref_buffer: *const ::std::os::raw::c_void,
        ref_buffer_size: i32,
        num_row: i64,
        num_classes: i32,
        parameters: *const ::std::os::raw::c_char,
        out: *mut DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Push data to existing dataset, if ``nrow + start_row == num_total_row``, will call ``dataset->FinishLoad``.\n # Arguments\n\n* `dataset` - Handle of dataset\n * `data` - Pointer to the data space\n * `data_type` - Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``\n * `nrow` - Number of rows\n * `ncol` - Number of columns\n * `start_row` - Row start index\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetPushRows(
        dataset: DatasetHandle,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nrow: i32,
        ncol: i32,
        start_row: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Push data to existing dataset.\n The general flow for a streaming scenario is:\n 1. create Dataset \"schema\" (e.g. ``LGBM_DatasetCreateFromSampledColumn``)\n 2. init them for thread-safe streaming (``LGBM_DatasetInitStreaming``)\n 3. push data (``LGBM_DatasetPushRowsWithMetadata`` or ``LGBM_DatasetPushRowsByCSRWithMetadata``)\n 4. call ``LGBM_DatasetMarkFinished``\n # Arguments\n\n* `dataset` - Handle of dataset\n * `data` - Pointer to the data space\n * `data_type` - Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``\n * `nrow` - Number of rows\n * `ncol` - Number of feature columns\n * `start_row` - Row start index, i.e., the index at which to start inserting data\n * `label` - Pointer to array with nrow labels\n * `weight` - Optional pointer to array with nrow weights\n * `init_score` - Optional pointer to array with nrow*nclasses initial scores, in column format\n * `query` - Optional pointer to array with nrow query values\n * `tid` - The id of the calling thread, from 0...N-1 threads\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetPushRowsWithMetadata(
        dataset: DatasetHandle,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nrow: i32,
        ncol: i32,
        start_row: i32,
        label: *const f32,
        weight: *const f32,
        init_score: *const f64,
        query: *const i32,
        tid: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Push data to existing dataset, if ``nrow + start_row == num_total_row``, will call ``dataset->FinishLoad``.\n # Arguments\n\n* `dataset` - Handle of dataset\n * `indptr` - Pointer to row headers\n * `indptr_type` - Type of ``indptr``, can be ``C_API_DTYPE_INT32`` or ``C_API_DTYPE_INT64``\n * `indices` - Pointer to column indices\n * `data` - Pointer to the data space\n * `data_type` - Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``\n * `nindptr` - Number of rows in the matrix + 1\n * `nelem` - Number of nonzero elements in the matrix\n * `num_col` - Number of columns\n * `start_row` - Row start index\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetPushRowsByCSR(
        dataset: DatasetHandle,
        indptr: *const ::std::os::raw::c_void,
        indptr_type: ::std::os::raw::c_int,
        indices: *const i32,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nindptr: i64,
        nelem: i64,
        num_col: i64,
        start_row: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Push CSR data to existing dataset. (See ``LGBM_DatasetPushRowsWithMetadata`` for more details.)\n # Arguments\n\n* `dataset` - Handle of dataset\n * `indptr` - Pointer to row headers\n * `indptr_type` - Type of ``indptr``, can be ``C_API_DTYPE_INT32`` or ``C_API_DTYPE_INT64``\n * `indices` - Pointer to column indices\n * `data` - Pointer to the data space\n * `data_type` - Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``\n * `nindptr` - Number of rows in the matrix + 1\n * `nelem` - Number of nonzero elements in the matrix\n * `start_row` - Row start index\n * `label` - Pointer to array with nindptr-1 labels\n * `weight` - Optional pointer to array with nindptr-1 weights\n * `init_score` - Optional pointer to array with (nindptr-1)*nclasses initial scores, in column format\n * `query` - Optional pointer to array with nindptr-1 query values\n * `tid` - The id of the calling thread, from 0...N-1 threads\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetPushRowsByCSRWithMetadata(
        dataset: DatasetHandle,
        indptr: *const ::std::os::raw::c_void,
        indptr_type: ::std::os::raw::c_int,
        indices: *const i32,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nindptr: i64,
        nelem: i64,
        start_row: i64,
        label: *const f32,
        weight: *const f32,
        init_score: *const f64,
        query: *const i32,
        tid: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Set whether or not the Dataset waits for a manual MarkFinished call or calls FinishLoad on itself automatically.\n Set to 1 for streaming scenario, and use ``LGBM_DatasetMarkFinished`` to manually finish the Dataset.\n # Arguments\n\n* `dataset` - Handle of dataset\n * `wait` - Whether to wait or not (1 or 0)\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetSetWaitForManualFinish(
        dataset: DatasetHandle,
        wait: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Mark the Dataset as complete by calling ``dataset->FinishLoad``.\n # Arguments\n\n* `dataset` - Handle of dataset\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetMarkFinished(dataset: DatasetHandle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Create a dataset from CSR format.\n # Arguments\n\n* `indptr` - Pointer to row headers\n * `indptr_type` - Type of ``indptr``, can be ``C_API_DTYPE_INT32`` or ``C_API_DTYPE_INT64``\n * `indices` - Pointer to column indices\n * `data` - Pointer to the data space\n * `data_type` - Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``\n * `nindptr` - Number of rows in the matrix + 1\n * `nelem` - Number of nonzero elements in the matrix\n * `num_col` - Number of columns\n * `parameters` - Additional parameters\n * `reference` - Used to align bin mapper with other dataset, nullptr means isn't used\n * `out` (direction out) - Created dataset\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetCreateFromCSR(
        indptr: *const ::std::os::raw::c_void,
        indptr_type: ::std::os::raw::c_int,
        indices: *const i32,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nindptr: i64,
        nelem: i64,
        num_col: i64,
        parameters: *const ::std::os::raw::c_char,
        reference: DatasetHandle,
        out: *mut DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Create a dataset from CSR format through callbacks.\n # Arguments\n\n* `get_row_funptr` - Pointer to ``std::function<void(int idx, std::vector<std::pair<int, double>>& ret)>``\n (called for every row and expected to clear and fill ``ret``)\n * `num_rows` - Number of rows\n * `num_col` - Number of columns\n * `parameters` - Additional parameters\n * `reference` - Used to align bin mapper with other dataset, nullptr means isn't used\n * `out` (direction out) - Created dataset\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetCreateFromCSRFunc(
        get_row_funptr: *mut ::std::os::raw::c_void,
        num_rows: ::std::os::raw::c_int,
        num_col: i64,
        parameters: *const ::std::os::raw::c_char,
        reference: DatasetHandle,
        out: *mut DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Create a dataset from CSC format.\n # Arguments\n\n* `col_ptr` - Pointer to column headers\n * `col_ptr_type` - Type of ``col_ptr``, can be ``C_API_DTYPE_INT32`` or ``C_API_DTYPE_INT64``\n * `indices` - Pointer to row indices\n * `data` - Pointer to the data space\n * `data_type` - Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``\n * `ncol_ptr` - Number of columns in the matrix + 1\n * `nelem` - Number of nonzero elements in the matrix\n * `num_row` - Number of rows\n * `parameters` - Additional parameters\n * `reference` - Used to align bin mapper with other dataset, nullptr means isn't used\n * `out` (direction out) - Created dataset\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetCreateFromCSC(
        col_ptr: *const ::std::os::raw::c_void,
        col_ptr_type: ::std::os::raw::c_int,
        indices: *const i32,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        ncol_ptr: i64,
        nelem: i64,
        num_row: i64,
        parameters: *const ::std::os::raw::c_char,
        reference: DatasetHandle,
        out: *mut DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Create dataset from dense matrix.\n # Arguments\n\n* `data` - Pointer to the data space\n * `data_type` - Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``\n * `nrow` - Number of rows\n * `ncol` - Number of columns\n * `is_row_major` - 1 for row-major, 0 for column-major\n * `parameters` - Additional parameters\n * `reference` - Used to align bin mapper with other dataset, nullptr means isn't used\n * `out` (direction out) - Created dataset\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetCreateFromMat(
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nrow: i32,
        ncol: i32,
        is_row_major: ::std::os::raw::c_int,
        parameters: *const ::std::os::raw::c_char,
        reference: DatasetHandle,
        out: *mut DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Create dataset from array of dense matrices.\n # Arguments\n\n* `nmat` - Number of dense matrices\n * `data` - Pointer to the data space\n * `data_type` - Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``\n * `nrow` - Number of rows\n * `ncol` - Number of columns\n * `is_row_major` - Pointer to the data layouts. 1 for row-major, 0 for column-major\n * `parameters` - Additional parameters\n * `reference` - Used to align bin mapper with other dataset, nullptr means isn't used\n * `out` (direction out) - Created dataset\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetCreateFromMats(
        nmat: i32,
        data: *mut *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nrow: *mut i32,
        ncol: i32,
        is_row_major: *mut ::std::os::raw::c_int,
        parameters: *const ::std::os::raw::c_char,
        reference: DatasetHandle,
        out: *mut DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Create dataset from Arrow.\n # Arguments\n\n* `n_chunks` - The number of Arrow arrays passed to this function\n * `chunks` - Pointer to the list of Arrow arrays\n * `schema` - Pointer to the schema of all Arrow arrays\n * `parameters` - Additional parameters\n * `reference` - Used to align bin mapper with other dataset, nullptr means isn't used\n * `out` (direction out) - Created dataset\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetCreateFromArrow(
        n_chunks: i64,
        chunks: *const ArrowArray,
        schema: *const ArrowSchema,
        parameters: *const ::std::os::raw::c_char,
        reference: DatasetHandle,
        out: *mut DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Create subset of a data.\n # Arguments\n\n* `handle` - Handle of full dataset\n * `used_row_indices` - Indices used in subset\n * `num_used_row_indices` - Length of ``used_row_indices``\n * `parameters` - Additional parameters\n * `out` (direction out) - Subset of data\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetGetSubset(
        handle: DatasetHandle,
        used_row_indices: *const i32,
        num_used_row_indices: i32,
        parameters: *const ::std::os::raw::c_char,
        out: *mut DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Save feature names to dataset.\n # Arguments\n\n* `handle` - Handle of dataset\n * `feature_names` - Feature names\n * `num_feature_names` - Number of feature names\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetSetFeatureNames(
        handle: DatasetHandle,
        feature_names: *mut *const ::std::os::raw::c_char,
        num_feature_names: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get feature names of dataset.\n # Arguments\n\n* `handle` - Handle of dataset\n * `len` - Number of ``char*`` pointers stored at ``out_strs``.\n If smaller than the max size, only this many strings are copied\n * `num_feature_names` (direction out) - Number of feature names\n * `buffer_len` - Size of pre-allocated strings.\n Content is copied up to ``buffer_len - 1`` and null-terminated\n * `out_buffer_len` (direction out) - String sizes required to do the full string copies\n * `feature_names` (direction out) - Feature names, should pre-allocate memory\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetGetFeatureNames(
        handle: DatasetHandle,
        len: ::std::os::raw::c_int,
        num_feature_names: *mut ::std::os::raw::c_int,
        buffer_len: usize,
        out_buffer_len: *mut usize,
        feature_names: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Free space for dataset.\n # Arguments\n\n* `handle` - Handle of dataset to be freed\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetFree(handle: DatasetHandle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Save dataset to binary file.\n # Arguments\n\n* `handle` - Handle of dataset\n * `filename` - The name of the file\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetSaveBinary(
        handle: DatasetHandle,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Create a dataset schema representation as a binary byte array (excluding data).\n # Arguments\n\n* `handle` - Handle of dataset\n * `out` (direction out) - The output byte array\n * `out_len` (direction out) - The length of the output byte array (returned for convenience)\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetSerializeReferenceToBinary(
        handle: DatasetHandle,
        out: *mut ByteBufferHandle,
        out_len: *mut i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Save dataset to text file, intended for debugging use only.\n # Arguments\n\n* `handle` - Handle of dataset\n * `filename` - The name of the file\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetDumpText(
        handle: DatasetHandle,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Set vector to a content in info.\n > **Note:** - _group_ only works for ``C_API_DTYPE_INT32``;\n - _label_ and _weight_ only work for ``C_API_DTYPE_FLOAT32``;\n - _init_score_ only works for ``C_API_DTYPE_FLOAT64``.\n # Arguments\n\n* `handle` - Handle of dataset\n * `field_name` - Field name, can be _label,_ _weight,_ _init_score,_ _group_\n * `field_data` - Pointer to data vector\n * `num_element` - Number of elements in ``field_data``\n * `type` - Type of ``field_data`` pointer, can be ``C_API_DTYPE_INT32``, ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetSetField(
        handle: DatasetHandle,
        field_name: *const ::std::os::raw::c_char,
        field_data: *const ::std::os::raw::c_void,
        num_element: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Set vector to a content in info.\n > **Note:** - _group_ converts input datatype into ``int32``;\n - _label_ and _weight_ convert input datatype into ``float32``;\n - _init_score_ converts input datatype into ``float64``.\n # Arguments\n\n* `handle` - Handle of dataset\n * `field_name` - Field name, can be _label,_ _weight,_ _init_score,_ _group_\n * `n_chunks` - The number of Arrow arrays passed to this function\n * `chunks` - Pointer to the list of Arrow arrays\n * `schema` - Pointer to the schema of all Arrow arrays\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetSetFieldFromArrow(
        handle: DatasetHandle,
        field_name: *const ::std::os::raw::c_char,
        n_chunks: i64,
        chunks: *const ArrowArray,
        schema: *const ArrowSchema,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get info vector from dataset.\n # Arguments\n\n* `handle` - Handle of dataset\n * `field_name` - Field name\n * `out_len` (direction out) - Used to set result length\n * `out_ptr` (direction out) - Pointer to the result\n * `out_type` (direction out) - Type of result pointer, can be ``C_API_DTYPE_INT32``, ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetGetField(
        handle: DatasetHandle,
        field_name: *const ::std::os::raw::c_char,
        out_len: *mut ::std::os::raw::c_int,
        out_ptr: *mut *const ::std::os::raw::c_void,
        out_type: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Raise errors for attempts to update dataset parameters.\n # Arguments\n\n* `old_parameters` - Current dataset parameters\n * `new_parameters` - New dataset parameters\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetUpdateParamChecking(
        old_parameters: *const ::std::os::raw::c_char,
        new_parameters: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get number of data points.\n # Arguments\n\n* `handle` - Handle of dataset\n * `out` (direction out) - The address to hold number of data points\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetGetNumData(
        handle: DatasetHandle,
        out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get number of features.\n # Arguments\n\n* `handle` - Handle of dataset\n * `out` (direction out) - The address to hold number of features\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetGetNumFeature(
        handle: DatasetHandle,
        out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get number of bins for feature.\n # Arguments\n\n* `handle` - Handle of dataset\n * `feature` - Index of the feature\n * `out` (direction out) - The address to hold number of bins\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetGetFeatureNumBin(
        handle: DatasetHandle,
        feature: ::std::os::raw::c_int,
        out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Add features from ``source`` to ``target``.\n # Arguments\n\n* `target` - The handle of the dataset to add features to\n * `source` - The handle of the dataset to take features from\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetAddFeaturesFrom(
        target: DatasetHandle,
        source: DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get int representing whether booster is fitting linear trees.\n # Arguments\n\n* `handle` - Handle of booster\n * `out` (direction out) - The address to hold linear trees indicator\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetLinear(
        handle: BoosterHandle,
        out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Create a new boosting learner.\n # Arguments\n\n* `train_data` - Training dataset\n * `parameters` - Parameters in format 'key1=value1 key2=value2'\n * `out` (direction out) - Handle of created booster\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterCreate(
        train_data: DatasetHandle,
        parameters: *const ::std::os::raw::c_char,
        out: *mut BoosterHandle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Load an existing booster from model file.\n # Arguments\n\n* `filename` - Filename of model\n * `out_num_iterations` (direction out) - Number of iterations of this booster\n * `out` (direction out) - Handle of created booster\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterCreateFromModelfile(
        filename: *const ::std::os::raw::c_char,
        out_num_iterations: *mut ::std::os::raw::c_int,
        out: *mut BoosterHandle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Load an existing booster from string.\n # Arguments\n\n* `model_str` - Model string\n * `out_num_iterations` (direction out) - Number of iterations of this booster\n * `out` (direction out) - Handle of created booster\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterLoadModelFromString(
        model_str: *const ::std::os::raw::c_char,
        out_num_iterations: *mut ::std::os::raw::c_int,
        out: *mut BoosterHandle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get parameters as JSON string.\n # Arguments\n\n* `handle` - Handle of booster\n * `buffer_len` - Allocated space for string\n * `out_len` (direction out) - Actual size of string\n * `out_str` (direction out) - JSON string containing parameters\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetLoadedParam(
        handle: BoosterHandle,
        buffer_len: i64,
        out_len: *mut i64,
        out_str: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Free space for booster.\n # Arguments\n\n* `handle` - Handle of booster to be freed\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterFree(handle: BoosterHandle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Shuffle models.\n # Arguments\n\n* `handle` - Handle of booster\n * `start_iter` - The first iteration that will be shuffled\n * `end_iter` - The last iteration that will be shuffled\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterShuffleModels(
        handle: BoosterHandle,
        start_iter: ::std::os::raw::c_int,
        end_iter: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Merge model from ``other_handle`` into ``handle``.\n # Arguments\n\n* `handle` - Handle of booster, will merge another booster into this one\n * `other_handle` - Other handle of booster\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterMerge(
        handle: BoosterHandle,
        other_handle: BoosterHandle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Add new validation data to booster.\n # Arguments\n\n* `handle` - Handle of booster\n * `valid_data` - Validation dataset\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterAddValidData(
        handle: BoosterHandle,
        valid_data: DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Reset training data for booster.\n # Arguments\n\n* `handle` - Handle of booster\n * `train_data` - Training dataset\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterResetTrainingData(
        handle: BoosterHandle,
        train_data: DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Reset config for booster.\n # Arguments\n\n* `handle` - Handle of booster\n * `parameters` - Parameters in format 'key1=value1 key2=value2'\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterResetParameter(
        handle: BoosterHandle,
        parameters: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get number of classes.\n # Arguments\n\n* `handle` - Handle of booster\n * `out_len` (direction out) - Number of classes\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetNumClasses(
        handle: BoosterHandle,
        out_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Update the model for one iteration.\n # Arguments\n\n* `handle` - Handle of booster\n * `is_finished` (direction out) - 1 means the update was successfully finished (cannot split any more), 0 indicates failure\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterUpdateOneIter(
        handle: BoosterHandle,
        is_finished: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Refit the tree model using the new data (online learning).\n # Arguments\n\n* `handle` - Handle of booster\n * `leaf_preds` - Pointer to predicted leaf indices\n * `nrow` - Number of rows of ``leaf_preds``\n * `ncol` - Number of columns of ``leaf_preds``\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterRefit(
        handle: BoosterHandle,
        leaf_preds: *const i32,
        nrow: i32,
        ncol: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Update the model by specifying gradient and Hessian directly\n (this can be used to support customized loss functions).\n > **Note:** The length of the arrays referenced by ``grad`` and ``hess`` must be equal to\n ``num_class * num_train_data``, this is not verified by the library, the caller must ensure this.\n # Arguments\n\n* `handle` - Handle of booster\n * `grad` - The first order derivative (gradient) statistics\n * `hess` - The second order derivative (Hessian) statistics\n * `is_finished` (direction out) - 1 means the update was successfully finished (cannot split any more), 0 indicates failure\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterUpdateOneIterCustom(
        handle: BoosterHandle,
        grad: *const f32,
        hess: *const f32,
        is_finished: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Rollback one iteration.\n # Arguments\n\n* `handle` - Handle of booster\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterRollbackOneIter(handle: BoosterHandle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get index of the current boosting iteration.\n # Arguments\n\n* `handle` - Handle of booster\n * `out_iteration` (direction out) - Index of the current boosting iteration\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetCurrentIteration(
        handle: BoosterHandle,
        out_iteration: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get number of trees per iteration.\n # Arguments\n\n* `handle` - Handle of booster\n * `out_tree_per_iteration` (direction out) - Number of trees per iteration\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterNumModelPerIteration(
        handle: BoosterHandle,
        out_tree_per_iteration: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get number of weak sub-models.\n # Arguments\n\n* `handle` - Handle of booster\n * `out_models` (direction out) - Number of weak sub-models\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterNumberOfTotalModel(
        handle: BoosterHandle,
        out_models: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get number of evaluation metrics.\n # Arguments\n\n* `handle` - Handle of booster\n * `out_len` (direction out) - Total number of evaluation metrics\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetEvalCounts(
        handle: BoosterHandle,
        out_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get names of evaluation metrics.\n # Arguments\n\n* `handle` - Handle of booster\n * `len` - Number of ``char*`` pointers stored at ``out_strs``.\n If smaller than the max size, only this many strings are copied\n * `out_len` (direction out) - Total number of evaluation metrics\n * `buffer_len` - Size of pre-allocated strings.\n Content is copied up to ``buffer_len - 1`` and null-terminated\n * `out_buffer_len` (direction out) - String sizes required to do the full string copies\n * `out_strs` (direction out) - Names of evaluation metrics, should pre-allocate memory\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetEvalNames(
        handle: BoosterHandle,
        len: ::std::os::raw::c_int,
        out_len: *mut ::std::os::raw::c_int,
        buffer_len: usize,
        out_buffer_len: *mut usize,
        out_strs: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get names of features.\n # Arguments\n\n* `handle` - Handle of booster\n * `len` - Number of ``char*`` pointers stored at ``out_strs``.\n If smaller than the max size, only this many strings are copied\n * `out_len` (direction out) - Total number of features\n * `buffer_len` - Size of pre-allocated strings.\n Content is copied up to ``buffer_len - 1`` and null-terminated\n * `out_buffer_len` (direction out) - String sizes required to do the full string copies\n * `out_strs` (direction out) - Names of features, should pre-allocate memory\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetFeatureNames(
        handle: BoosterHandle,
        len: ::std::os::raw::c_int,
        out_len: *mut ::std::os::raw::c_int,
        buffer_len: usize,
        out_buffer_len: *mut usize,
        out_strs: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Check that the feature names of the data match the ones used to train the booster.\n # Arguments\n\n* `handle` - Handle of booster\n * `data_names` - Array with the feature names in the data\n * `data_num_features` - Number of features in the data\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterValidateFeatureNames(
        handle: BoosterHandle,
        data_names: *mut *const ::std::os::raw::c_char,
        data_num_features: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get number of features.\n # Arguments\n\n* `handle` - Handle of booster\n * `out_len` (direction out) - Total number of features\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetNumFeature(
        handle: BoosterHandle,
        out_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get evaluation for training data and validation data.\n > **Note:** 1. You should call ``LGBM_BoosterGetEvalNames`` first to get the names of evaluation metrics.\n 2. You should pre-allocate memory for ``out_results``, you can get its length by ``LGBM_BoosterGetEvalCounts``.\n # Arguments\n\n* `handle` - Handle of booster\n * `data_idx` - Index of data, 0: training data, 1: 1st validation data, 2: 2nd validation data and so on\n * `out_len` (direction out) - Length of output result\n * `out_results` (direction out) - Array with evaluation results\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetEval(
        handle: BoosterHandle,
        data_idx: ::std::os::raw::c_int,
        out_len: *mut ::std::os::raw::c_int,
        out_results: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get number of predictions for training data and validation data\n (this can be used to support customized evaluation functions).\n # Arguments\n\n* `handle` - Handle of booster\n * `data_idx` - Index of data, 0: training data, 1: 1st validation data, 2: 2nd validation data and so on\n * `out_len` (direction out) - Number of predictions\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetNumPredict(
        handle: BoosterHandle,
        data_idx: ::std::os::raw::c_int,
        out_len: *mut i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get prediction for training data and validation data.\n > **Note:** You should pre-allocate memory for ``out_result``, its length is equal to ``num_class * num_data``.\n # Arguments\n\n* `handle` - Handle of booster\n * `data_idx` - Index of data, 0: training data, 1: 1st validation data, 2: 2nd validation data and so on\n * `out_len` (direction out) - Length of output result\n * `out_result` (direction out) - Pointer to array with predictions\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetPredict(
        handle: BoosterHandle,
        data_idx: ::std::os::raw::c_int,
        out_len: *mut i64,
        out_result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Make prediction for file.\n # Arguments\n\n* `handle` - Handle of booster\n * `data_filename` - Filename of file with data\n * `data_has_header` - Whether file has header or not\n * `predict_type` - What should be predicted\n - ``C_API_PREDICT_NORMAL``: normal prediction, with transform (if needed);\n - ``C_API_PREDICT_RAW_SCORE``: raw score;\n - ``C_API_PREDICT_LEAF_INDEX``: leaf index;\n - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)\n * `start_iteration` - Start index of the iteration to predict\n * `num_iteration` - Number of iterations for prediction, <= 0 means no limit\n * `parameter` - Other parameters for prediction, e.g. early stopping for prediction\n * `result_filename` - Filename of result file in which predictions will be written\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForFile(
        handle: BoosterHandle,
        data_filename: *const ::std::os::raw::c_char,
        data_has_header: ::std::os::raw::c_int,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        parameter: *const ::std::os::raw::c_char,
        result_filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get number of predictions.\n # Arguments\n\n* `handle` - Handle of booster\n * `num_row` - Number of rows\n * `predict_type` - What should be predicted\n - ``C_API_PREDICT_NORMAL``: normal prediction, with transform (if needed);\n - ``C_API_PREDICT_RAW_SCORE``: raw score;\n - ``C_API_PREDICT_LEAF_INDEX``: leaf index;\n - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)\n * `start_iteration` - Start index of the iteration to predict\n * `num_iteration` - Number of iterations for prediction, <= 0 means no limit\n * `out_len` (direction out) - Length of prediction\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterCalcNumPredict(
        handle: BoosterHandle,
        num_row: ::std::os::raw::c_int,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        out_len: *mut i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Release FastConfig object.\n\n # Arguments\n\n* `fastConfig` - Handle to the FastConfig object acquired with a ``*FastInit()`` method.\n # Returns\n\n0 when it succeeds, -1 when failure happens"]
    pub fn LGBM_FastConfigFree(fastConfig: FastConfigHandle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Make prediction for a new dataset in CSR format.\n > **Note:** You should pre-allocate memory for ``out_result``:\n - for normal and raw score, its length is equal to ``num_class * num_data``;\n - for leaf index, its length is equal to ``num_class * num_data * num_iteration``;\n - for feature contributions, its length is equal to ``num_class * num_data * (num_feature + 1)``.\n # Arguments\n\n* `handle` - Handle of booster\n * `indptr` - Pointer to row headers\n * `indptr_type` - Type of ``indptr``, can be ``C_API_DTYPE_INT32`` or ``C_API_DTYPE_INT64``\n * `indices` - Pointer to column indices\n * `data` - Pointer to the data space\n * `data_type` - Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``\n * `nindptr` - Number of rows in the matrix + 1\n * `nelem` - Number of nonzero elements in the matrix\n * `num_col` - Number of columns\n * `predict_type` - What should be predicted\n - ``C_API_PREDICT_NORMAL``: normal prediction, with transform (if needed);\n - ``C_API_PREDICT_RAW_SCORE``: raw score;\n - ``C_API_PREDICT_LEAF_INDEX``: leaf index;\n - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)\n * `start_iteration` - Start index of the iteration to predict\n * `num_iteration` - Number of iterations for prediction, <= 0 means no limit\n * `parameter` - Other parameters for prediction, e.g. early stopping for prediction\n * `out_len` (direction out) - Length of output result\n * `out_result` (direction out) - Pointer to array with predictions\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForCSR(
        handle: BoosterHandle,
        indptr: *const ::std::os::raw::c_void,
        indptr_type: ::std::os::raw::c_int,
        indices: *const i32,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nindptr: i64,
        nelem: i64,
        num_col: i64,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        parameter: *const ::std::os::raw::c_char,
        out_len: *mut i64,
        out_result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Make sparse prediction for a new dataset in CSR or CSC format. Currently only used for feature contributions.\n > **Note:** The outputs are pre-allocated, as they can vary for each invocation, but the shape should be the same:\n - for feature contributions, the shape of sparse matrix will be ``num_class * num_data * (num_feature + 1)``.\n The output indptr_type for the sparse matrix will be the same as the given input indptr_type.\n Call ``LGBM_BoosterFreePredictSparse`` to deallocate resources.\n # Arguments\n\n* `handle` - Handle of booster\n * `indptr` - Pointer to row headers for CSR or column headers for CSC\n * `indptr_type` - Type of ``indptr``, can be ``C_API_DTYPE_INT32`` or ``C_API_DTYPE_INT64``\n * `indices` - Pointer to column indices for CSR or row indices for CSC\n * `data` - Pointer to the data space\n * `data_type` - Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``\n * `nindptr` - Number of entries in ``indptr``\n * `nelem` - Number of nonzero elements in the matrix\n * `num_col_or_row` - Number of columns for CSR or number of rows for CSC\n * `predict_type` - What should be predicted, only feature contributions supported currently\n - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)\n * `start_iteration` - Start index of the iteration to predict\n * `num_iteration` - Number of iterations for prediction, <= 0 means no limit\n * `parameter` - Other parameters for prediction, e.g. early stopping for prediction\n * `matrix_type` - Type of matrix input and output, can be ``C_API_MATRIX_TYPE_CSR`` or ``C_API_MATRIX_TYPE_CSC``\n * `out_len` (direction out) - Length of output data and output indptr (pointer to an array with two entries where to write them)\n * `out_indptr` (direction out) - Pointer to output row headers for CSR or column headers for CSC\n * `out_indices` (direction out) - Pointer to sparse column indices for CSR or row indices for CSC\n * `out_data` (direction out) - Pointer to sparse data space\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterPredictSparseOutput(
        handle: BoosterHandle,
        indptr: *const ::std::os::raw::c_void,
        indptr_type: ::std::os::raw::c_int,
        indices: *const i32,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nindptr: i64,
        nelem: i64,
        num_col_or_row: i64,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        parameter: *const ::std::os::raw::c_char,
        matrix_type: ::std::os::raw::c_int,
        out_len: *mut i64,
        out_indptr: *mut *mut ::std::os::raw::c_void,
        out_indices: *mut *mut i32,
        out_data: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Method corresponding to ``LGBM_BoosterPredictSparseOutput`` to free the allocated data.\n # Arguments\n\n* `indptr` - Pointer to output row headers or column headers to be deallocated\n * `indices` - Pointer to sparse indices to be deallocated\n * `data` - Pointer to sparse data space to be deallocated\n * `indptr_type` - Type of ``indptr``, can be ``C_API_DTYPE_INT32`` or ``C_API_DTYPE_INT64``\n * `data_type` - Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterFreePredictSparse(
        indptr: *mut ::std::os::raw::c_void,
        indices: *mut i32,
        data: *mut ::std::os::raw::c_void,
        indptr_type: ::std::os::raw::c_int,
        data_type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Make prediction for a new dataset in CSR format. This method re-uses the internal predictor structure\n from previous calls and is optimized for single row invocation.\n > **Note:** You should pre-allocate memory for ``out_result``:\n - for normal and raw score, its length is equal to ``num_class * num_data``;\n - for leaf index, its length is equal to ``num_class * num_data * num_iteration``;\n - for feature contributions, its length is equal to ``num_class * num_data * (num_feature + 1)``.\n # Arguments\n\n* `handle` - Handle of booster\n * `indptr` - Pointer to row headers\n * `indptr_type` - Type of ``indptr``, can be ``C_API_DTYPE_INT32`` or ``C_API_DTYPE_INT64``\n * `indices` - Pointer to column indices\n * `data` - Pointer to the data space\n * `data_type` - Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``\n * `nindptr` - Number of rows in the matrix + 1\n * `nelem` - Number of nonzero elements in the matrix\n * `num_col` - Number of columns\n * `predict_type` - What should be predicted\n - ``C_API_PREDICT_NORMAL``: normal prediction, with transform (if needed);\n - ``C_API_PREDICT_RAW_SCORE``: raw score;\n - ``C_API_PREDICT_LEAF_INDEX``: leaf index;\n - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)\n * `start_iteration` - Start index of the iteration to predict\n * `num_iteration` - Number of iterations for prediction, <= 0 means no limit\n * `parameter` - Other parameters for prediction, e.g. early stopping for prediction\n * `out_len` (direction out) - Length of output result\n * `out_result` (direction out) - Pointer to array with predictions\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForCSRSingleRow(
        handle: BoosterHandle,
        indptr: *const ::std::os::raw::c_void,
        indptr_type: ::std::os::raw::c_int,
        indices: *const i32,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nindptr: i64,
        nelem: i64,
        num_col: i64,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        parameter: *const ::std::os::raw::c_char,
        out_len: *mut i64,
        out_result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Initialize and return a ``FastConfigHandle`` for use with ``LGBM_BoosterPredictForCSRSingleRowFast``.\n\n Release the ``FastConfig`` by passing its handle to ``LGBM_FastConfigFree`` when no longer needed.\n\n # Arguments\n\n* `handle` - Booster handle\n * `predict_type` - What should be predicted\n - ``C_API_PREDICT_NORMAL``: normal prediction, with transform (if needed);\n - ``C_API_PREDICT_RAW_SCORE``: raw score;\n - ``C_API_PREDICT_LEAF_INDEX``: leaf index;\n - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)\n * `start_iteration` - Start index of the iteration to predict\n * `num_iteration` - Number of iterations for prediction, <= 0 means no limit\n * `data_type` - Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``\n * `num_col` - Number of columns\n * `parameter` - Other parameters for prediction, e.g. early stopping for prediction\n * `out_fastConfig` (direction out) - FastConfig object with which you can call ``LGBM_BoosterPredictForCSRSingleRowFast``\n # Returns\n\n0 when it succeeds, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForCSRSingleRowFastInit(
        handle: BoosterHandle,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        data_type: ::std::os::raw::c_int,
        num_col: i64,
        parameter: *const ::std::os::raw::c_char,
        out_fastConfig: *mut FastConfigHandle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Faster variant of ``LGBM_BoosterPredictForCSRSingleRow``.\n\n Score single rows after setup with ``LGBM_BoosterPredictForCSRSingleRowFastInit``.\n\n By removing the setup steps from this call extra optimizations can be made like\n initializing the config only once, instead of once per call.\n\n > **Note:** Setting up the number of threads is only done once at ``LGBM_BoosterPredictForCSRSingleRowFastInit``\n instead of at each prediction.\n If you use a different number of threads in other calls, you need to start the setup process over,\n or that number of threads will be used for these calls as well.\n\n > **Note:** You should pre-allocate memory for ``out_result``:\n - for normal and raw score, its length is equal to ``num_class * num_data``;\n - for leaf index, its length is equal to ``num_class * num_data * num_iteration``;\n - for feature contributions, its length is equal to ``num_class * num_data * (num_feature + 1)``.\n\n # Arguments\n\n* `fastConfig_handle` - FastConfig object handle returned by ``LGBM_BoosterPredictForCSRSingleRowFastInit``\n * `indptr` - Pointer to row headers\n * `indptr_type` - Type of ``indptr``, can be ``C_API_DTYPE_INT32`` or ``C_API_DTYPE_INT64``\n * `indices` - Pointer to column indices\n * `data` - Pointer to the data space\n * `nindptr` - Number of rows in the matrix + 1\n * `nelem` - Number of nonzero elements in the matrix\n * `out_len` (direction out) - Length of output result\n * `out_result` (direction out) - Pointer to array with predictions\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForCSRSingleRowFast(
        fastConfig_handle: FastConfigHandle,
        indptr: *const ::std::os::raw::c_void,
        indptr_type: ::std::os::raw::c_int,
        indices: *const i32,
        data: *const ::std::os::raw::c_void,
        nindptr: i64,
        nelem: i64,
        out_len: *mut i64,
        out_result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Make prediction for a new dataset in CSC format.\n > **Note:** You should pre-allocate memory for ``out_result``:\n - for normal and raw score, its length is equal to ``num_class * num_data``;\n - for leaf index, its length is equal to ``num_class * num_data * num_iteration``;\n - for feature contributions, its length is equal to ``num_class * num_data * (num_feature + 1)``.\n # Arguments\n\n* `handle` - Handle of booster\n * `col_ptr` - Pointer to column headers\n * `col_ptr_type` - Type of ``col_ptr``, can be ``C_API_DTYPE_INT32`` or ``C_API_DTYPE_INT64``\n * `indices` - Pointer to row indices\n * `data` - Pointer to the data space\n * `data_type` - Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``\n * `ncol_ptr` - Number of columns in the matrix + 1\n * `nelem` - Number of nonzero elements in the matrix\n * `num_row` - Number of rows\n * `predict_type` - What should be predicted\n - ``C_API_PREDICT_NORMAL``: normal prediction, with transform (if needed);\n - ``C_API_PREDICT_RAW_SCORE``: raw score;\n - ``C_API_PREDICT_LEAF_INDEX``: leaf index;\n - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)\n * `start_iteration` - Start index of the iteration to predict\n * `num_iteration` - Number of iteration for prediction, <= 0 means no limit\n * `parameter` - Other parameters for prediction, e.g. early stopping for prediction\n * `out_len` (direction out) - Length of output result\n * `out_result` (direction out) - Pointer to array with predictions\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForCSC(
        handle: BoosterHandle,
        col_ptr: *const ::std::os::raw::c_void,
        col_ptr_type: ::std::os::raw::c_int,
        indices: *const i32,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        ncol_ptr: i64,
        nelem: i64,
        num_row: i64,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        parameter: *const ::std::os::raw::c_char,
        out_len: *mut i64,
        out_result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Make prediction for a new dataset.\n > **Note:** You should pre-allocate memory for ``out_result``:\n - for normal and raw score, its length is equal to ``num_class * num_data``;\n - for leaf index, its length is equal to ``num_class * num_data * num_iteration``;\n - for feature contributions, its length is equal to ``num_class * num_data * (num_feature + 1)``.\n # Arguments\n\n* `handle` - Handle of booster\n * `data` - Pointer to the data space\n * `data_type` - Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``\n * `nrow` - Number of rows\n * `ncol` - Number of columns\n * `is_row_major` - 1 for row-major, 0 for column-major\n * `predict_type` - What should be predicted\n - ``C_API_PREDICT_NORMAL``: normal prediction, with transform (if needed);\n - ``C_API_PREDICT_RAW_SCORE``: raw score;\n - ``C_API_PREDICT_LEAF_INDEX``: leaf index;\n - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)\n * `start_iteration` - Start index of the iteration to predict\n * `num_iteration` - Number of iteration for prediction, <= 0 means no limit\n * `parameter` - Other parameters for prediction, e.g. early stopping for prediction\n * `out_len` (direction out) - Length of output result\n * `out_result` (direction out) - Pointer to array with predictions\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForMat(
        handle: BoosterHandle,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nrow: i32,
        ncol: i32,
        is_row_major: ::std::os::raw::c_int,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        parameter: *const ::std::os::raw::c_char,
        out_len: *mut i64,
        out_result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Make prediction for a new dataset. This method re-uses the internal predictor structure\n from previous calls and is optimized for single row invocation.\n > **Note:** You should pre-allocate memory for ``out_result``:\n - for normal and raw score, its length is equal to ``num_class * num_data``;\n - for leaf index, its length is equal to ``num_class * num_data * num_iteration``;\n - for feature contributions, its length is equal to ``num_class * num_data * (num_feature + 1)``.\n # Arguments\n\n* `handle` - Handle of booster\n * `data` - Pointer to the data space\n * `data_type` - Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``\n * `ncol` - Number columns\n * `is_row_major` - 1 for row-major, 0 for column-major\n * `predict_type` - What should be predicted\n - ``C_API_PREDICT_NORMAL``: normal prediction, with transform (if needed);\n - ``C_API_PREDICT_RAW_SCORE``: raw score;\n - ``C_API_PREDICT_LEAF_INDEX``: leaf index;\n - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)\n * `start_iteration` - Start index of the iteration to predict\n * `num_iteration` - Number of iteration for prediction, <= 0 means no limit\n * `parameter` - Other parameters for prediction, e.g. early stopping for prediction\n * `out_len` (direction out) - Length of output result\n * `out_result` (direction out) - Pointer to array with predictions\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForMatSingleRow(
        handle: BoosterHandle,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        ncol: ::std::os::raw::c_int,
        is_row_major: ::std::os::raw::c_int,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        parameter: *const ::std::os::raw::c_char,
        out_len: *mut i64,
        out_result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Initialize and return a ``FastConfigHandle`` for use with ``LGBM_BoosterPredictForMatSingleRowFast``.\n\n Release the ``FastConfig`` by passing its handle to ``LGBM_FastConfigFree`` when no longer needed.\n\n # Arguments\n\n* `handle` - Booster handle\n * `predict_type` - What should be predicted\n - ``C_API_PREDICT_NORMAL``: normal prediction, with transform (if needed);\n - ``C_API_PREDICT_RAW_SCORE``: raw score;\n - ``C_API_PREDICT_LEAF_INDEX``: leaf index;\n - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)\n * `start_iteration` - Start index of the iteration to predict\n * `num_iteration` - Number of iterations for prediction, <= 0 means no limit\n * `data_type` - Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``\n * `ncol` - Number of columns\n * `parameter` - Other parameters for prediction, e.g. early stopping for prediction\n * `out_fastConfig` (direction out) - FastConfig object with which you can call ``LGBM_BoosterPredictForMatSingleRowFast``\n # Returns\n\n0 when it succeeds, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForMatSingleRowFastInit(
        handle: BoosterHandle,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        data_type: ::std::os::raw::c_int,
        ncol: i32,
        parameter: *const ::std::os::raw::c_char,
        out_fastConfig: *mut FastConfigHandle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Faster variant of ``LGBM_BoosterPredictForMatSingleRow``.\n\n Score a single row after setup with ``LGBM_BoosterPredictForMatSingleRowFastInit``.\n\n By removing the setup steps from this call extra optimizations can be made like\n initializing the config only once, instead of once per call.\n\n > **Note:** Setting up the number of threads is only done once at ``LGBM_BoosterPredictForMatSingleRowFastInit``\n instead of at each prediction.\n If you use a different number of threads in other calls, you need to start the setup process over,\n or that number of threads will be used for these calls as well.\n\n # Arguments\n\n* `fastConfig_handle` - FastConfig object handle returned by ``LGBM_BoosterPredictForMatSingleRowFastInit``\n * `data` - Single-row array data (no other way than row-major form).\n * `out_len` (direction out) - Length of output result\n * `out_result` (direction out) - Pointer to array with predictions\n # Returns\n\n0 when it succeeds, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForMatSingleRowFast(
        fastConfig_handle: FastConfigHandle,
        data: *const ::std::os::raw::c_void,
        out_len: *mut i64,
        out_result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Make prediction for a new dataset presented in a form of array of pointers to rows.\n > **Note:** You should pre-allocate memory for ``out_result``:\n - for normal and raw score, its length is equal to ``num_class * num_data``;\n - for leaf index, its length is equal to ``num_class * num_data * num_iteration``;\n - for feature contributions, its length is equal to ``num_class * num_data * (num_feature + 1)``.\n # Arguments\n\n* `handle` - Handle of booster\n * `data` - Pointer to the data space\n * `data_type` - Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``\n * `nrow` - Number of rows\n * `ncol` - Number columns\n * `predict_type` - What should be predicted\n - ``C_API_PREDICT_NORMAL``: normal prediction, with transform (if needed);\n - ``C_API_PREDICT_RAW_SCORE``: raw score;\n - ``C_API_PREDICT_LEAF_INDEX``: leaf index;\n - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)\n * `start_iteration` - Start index of the iteration to predict\n * `num_iteration` - Number of iteration for prediction, <= 0 means no limit\n * `parameter` - Other parameters for prediction, e.g. early stopping for prediction\n * `out_len` (direction out) - Length of output result\n * `out_result` (direction out) - Pointer to array with predictions\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForMats(
        handle: BoosterHandle,
        data: *mut *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nrow: i32,
        ncol: i32,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        parameter: *const ::std::os::raw::c_char,
        out_len: *mut i64,
        out_result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Make prediction for a new dataset.\n > **Note:** You should pre-allocate memory for ``out_result``:\n - for normal and raw score, its length is equal to ``num_class * num_data``;\n - for leaf index, its length is equal to ``num_class * num_data * num_iteration``;\n - for feature contributions, its length is equal to ``num_class * num_data * (num_feature + 1)``.\n # Arguments\n\n* `handle` - Handle of booster\n * `n_chunks` - The number of Arrow arrays passed to this function\n * `chunks` - Pointer to the list of Arrow arrays\n * `schema` - Pointer to the schema of all Arrow arrays\n * `predict_type` - What should be predicted\n - ``C_API_PREDICT_NORMAL``: normal prediction, with transform (if needed);\n - ``C_API_PREDICT_RAW_SCORE``: raw score;\n - ``C_API_PREDICT_LEAF_INDEX``: leaf index;\n - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)\n * `start_iteration` - Start index of the iteration to predict\n * `num_iteration` - Number of iteration for prediction, <= 0 means no limit\n * `parameter` - Other parameters for prediction, e.g. early stopping for prediction\n * `out_len` (direction out) - Length of output result\n * `out_result` (direction out) - Pointer to array with predictions\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForArrow(
        handle: BoosterHandle,
        n_chunks: i64,
        chunks: *const ArrowArray,
        schema: *const ArrowSchema,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        parameter: *const ::std::os::raw::c_char,
        out_len: *mut i64,
        out_result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Save model into file.\n # Arguments\n\n* `handle` - Handle of booster\n * `start_iteration` - Start index of the iteration that should be saved\n * `num_iteration` - Index of the iteration that should be saved, <= 0 means save all\n * `feature_importance_type` - Type of feature importance, can be ``C_API_FEATURE_IMPORTANCE_SPLIT`` or ``C_API_FEATURE_IMPORTANCE_GAIN``\n * `filename` - The name of the file\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterSaveModel(
        handle: BoosterHandle,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        feature_importance_type: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Save model to string.\n # Arguments\n\n* `handle` - Handle of booster\n * `start_iteration` - Start index of the iteration that should be saved\n * `num_iteration` - Index of the iteration that should be saved, <= 0 means save all\n * `feature_importance_type` - Type of feature importance, can be ``C_API_FEATURE_IMPORTANCE_SPLIT`` or ``C_API_FEATURE_IMPORTANCE_GAIN``\n * `buffer_len` - String buffer length, if ``buffer_len < out_len``, you should re-allocate buffer\n * `out_len` (direction out) - Actual output length\n * `out_str` (direction out) - String of model, should pre-allocate memory\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterSaveModelToString(
        handle: BoosterHandle,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        feature_importance_type: ::std::os::raw::c_int,
        buffer_len: i64,
        out_len: *mut i64,
        out_str: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Dump model to JSON.\n # Arguments\n\n* `handle` - Handle of booster\n * `start_iteration` - Start index of the iteration that should be dumped\n * `num_iteration` - Index of the iteration that should be dumped, <= 0 means dump all\n * `feature_importance_type` - Type of feature importance, can be ``C_API_FEATURE_IMPORTANCE_SPLIT`` or ``C_API_FEATURE_IMPORTANCE_GAIN``\n * `buffer_len` - String buffer length, if ``buffer_len < out_len``, you should re-allocate buffer\n * `out_len` (direction out) - Actual output length\n * `out_str` (direction out) - JSON format string of model, should pre-allocate memory\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterDumpModel(
        handle: BoosterHandle,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        feature_importance_type: ::std::os::raw::c_int,
        buffer_len: i64,
        out_len: *mut i64,
        out_str: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get leaf value.\n # Arguments\n\n* `handle` - Handle of booster\n * `tree_idx` - Index of tree\n * `leaf_idx` - Index of leaf\n * `out_val` (direction out) - Output result from the specified leaf\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetLeafValue(
        handle: BoosterHandle,
        tree_idx: ::std::os::raw::c_int,
        leaf_idx: ::std::os::raw::c_int,
        out_val: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Set leaf value.\n # Arguments\n\n* `handle` - Handle of booster\n * `tree_idx` - Index of tree\n * `leaf_idx` - Index of leaf\n * `val` - Leaf value\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterSetLeafValue(
        handle: BoosterHandle,
        tree_idx: ::std::os::raw::c_int,
        leaf_idx: ::std::os::raw::c_int,
        val: f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get model feature importance.\n # Arguments\n\n* `handle` - Handle of booster\n * `num_iteration` - Number of iterations for which feature importance is calculated, <= 0 means use all\n * `importance_type` - Method of importance calculation:\n - ``C_API_FEATURE_IMPORTANCE_SPLIT``: result contains numbers of times the feature is used in a model;\n - ``C_API_FEATURE_IMPORTANCE_GAIN``: result contains total gains of splits which use the feature\n * `out_results` (direction out) - Result array with feature importance\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterFeatureImportance(
        handle: BoosterHandle,
        num_iteration: ::std::os::raw::c_int,
        importance_type: ::std::os::raw::c_int,
        out_results: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get model upper bound value.\n # Arguments\n\n* `handle` - Handle of booster\n * `out_results` (direction out) - Result pointing to max value\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetUpperBoundValue(
        handle: BoosterHandle,
        out_results: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get model lower bound value.\n # Arguments\n\n* `handle` - Handle of booster\n * `out_results` (direction out) - Result pointing to min value\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetLowerBoundValue(
        handle: BoosterHandle,
        out_results: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Initialize the network.\n # Arguments\n\n* `machines` - List of machines in format 'ip1:port1,ip2:port2'\n * `local_listen_port` - TCP listen port for local machines\n * `listen_time_out` - Socket time-out in minutes\n * `num_machines` - Total number of machines\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_NetworkInit(
        machines: *const ::std::os::raw::c_char,
        local_listen_port: ::std::os::raw::c_int,
        listen_time_out: ::std::os::raw::c_int,
        num_machines: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Finalize the network.\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_NetworkFree() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Initialize the network with external collective functions.\n # Arguments\n\n* `num_machines` - Total number of machines\n * `rank` - Rank of local machine\n * `reduce_scatter_ext_fun` - The external reduce-scatter function\n * `allgather_ext_fun` - The external allgather function\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_NetworkInitWithFunctions(
        num_machines: ::std::os::raw::c_int,
        rank: ::std::os::raw::c_int,
        reduce_scatter_ext_fun: *mut ::std::os::raw::c_void,
        allgather_ext_fun: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Set maximum number of threads used by LightGBM routines in this process.\n # Arguments\n\n* `num_threads` - maximum number of threads used by LightGBM. -1 means defaulting to omp_get_num_threads().\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_SetMaxThreads(num_threads: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get current maximum number of threads used by LightGBM routines in this process.\n # Arguments\n\n* `out` (direction out) - current maximum number of threads used by LightGBM. -1 means defaulting to omp_get_num_threads().\n # Returns\n\n0 when succeed, -1 when failure happens"]
    pub fn LGBM_GetMaxThreads(out: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
